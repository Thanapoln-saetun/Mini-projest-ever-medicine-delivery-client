{"ast":null,"code":"import * as utils from './utils.js';\nimport { Base } from './Base.js';\nexport class Pointer extends Base {\n  constructor(offsetType, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.offsetType = offsetType;\n    this.type = type;\n    this.options = options;\n\n    if (this.type === 'void') {\n      this.type = null;\n    }\n\n    if (this.options.type == null) {\n      this.options.type = 'local';\n    }\n\n    if (this.options.allowNull == null) {\n      this.options.allowNull = true;\n    }\n\n    if (this.options.nullValue == null) {\n      this.options.nullValue = 0;\n    }\n\n    if (this.options.lazy == null) {\n      this.options.lazy = false;\n    }\n\n    if (this.options.relativeTo) {\n      if (typeof this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n\n      this.relativeToGetter = options.relativeTo;\n    }\n  }\n\n  decode(stream, ctx) {\n    const offset = this.offsetType.decode(stream, ctx); // handle NULL pointers\n\n    if (offset === this.options.nullValue && this.options.allowNull) {\n      return null;\n    }\n\n    let relative;\n\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx._startOffset;\n        break;\n\n      case 'immediate':\n        relative = stream.pos - this.offsetType.size();\n        break;\n\n      case 'parent':\n        relative = ctx.parent._startOffset;\n        break;\n\n      default:\n        var c = ctx;\n\n        while (c.parent) {\n          c = c.parent;\n        }\n\n        relative = c._startOffset || 0;\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(ctx);\n    }\n\n    const ptr = offset + relative;\n\n    if (this.type != null) {\n      let val = null;\n\n      const decodeValue = () => {\n        if (val != null) {\n          return val;\n        }\n\n        const {\n          pos\n        } = stream;\n        stream.pos = ptr;\n        val = this.type.decode(stream, ctx);\n        stream.pos = pos;\n        return val;\n      }; // If this is a lazy pointer, define a getter to decode only when needed.\n      // This obviously only works when the pointer is contained by a Struct.\n\n\n      if (this.options.lazy) {\n        return new utils.PropertyDescriptor({\n          get: decodeValue\n        });\n      }\n\n      return decodeValue();\n    } else {\n      return ptr;\n    }\n  }\n\n  size(val, ctx) {\n    const parent = ctx;\n\n    switch (this.options.type) {\n      case 'local':\n      case 'immediate':\n        break;\n\n      case 'parent':\n        ctx = ctx.parent;\n        break;\n\n      default:\n        // global\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n\n    }\n\n    let {\n      type\n    } = this;\n\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({\n        type\n      } = val);\n      val = val.value;\n    }\n\n    if (val && ctx) {\n      // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n      let size = type.size(val, parent);\n      ctx.pointerSize += size;\n    }\n\n    return this.offsetType.size();\n  }\n\n  encode(stream, val, ctx) {\n    let relative;\n    const parent = ctx;\n\n    if (val == null) {\n      this.offsetType.encode(stream, this.options.nullValue);\n      return;\n    }\n\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx.startOffset;\n        break;\n\n      case 'immediate':\n        relative = stream.pos + this.offsetType.size(val, parent);\n        break;\n\n      case 'parent':\n        ctx = ctx.parent;\n        relative = ctx.startOffset;\n        break;\n\n      default:\n        // global\n        relative = 0;\n\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(parent.val);\n    }\n\n    this.offsetType.encode(stream, ctx.pointerOffset - relative);\n    let {\n      type\n    } = this;\n\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({\n        type\n      } = val);\n      val = val.value;\n    }\n\n    ctx.pointers.push({\n      type,\n      val,\n      parent\n    });\n    return ctx.pointerOffset += type.size(val, parent);\n  }\n\n} // A pointer whose type is determined at decode time\n\nexport class VoidPointer {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n\n}","map":{"version":3,"names":["utils","Base","Pointer","constructor","offsetType","type","options","allowNull","nullValue","lazy","relativeTo","Error","relativeToGetter","decode","stream","ctx","offset","relative","_startOffset","pos","size","parent","c","ptr","val","decodeValue","PropertyDescriptor","get","VoidPointer","value","pointerSize","encode","startOffset","pointerOffset","pointers","push"],"sources":["E:/Mern login/client/node_modules/restructure/src/Pointer.js"],"sourcesContent":["import * as utils from './utils.js';\nimport {Base} from './Base.js';\n\nexport class Pointer extends Base {\n  constructor(offsetType, type, options = {}) {\n    super();\n    this.offsetType = offsetType;\n    this.type = type;\n    this.options = options;\n    if (this.type === 'void') { this.type = null; }\n    if (this.options.type == null) { this.options.type = 'local'; }\n    if (this.options.allowNull == null) { this.options.allowNull = true; }\n    if (this.options.nullValue == null) { this.options.nullValue = 0; }\n    if (this.options.lazy == null) { this.options.lazy = false; }\n    if (this.options.relativeTo) {\n      if (typeof this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n      this.relativeToGetter = options.relativeTo;\n    }\n  }\n\n  decode(stream, ctx) {\n    const offset = this.offsetType.decode(stream, ctx);\n\n    // handle NULL pointers\n    if ((offset === this.options.nullValue) && this.options.allowNull) {\n      return null;\n    }\n\n    let relative;\n    switch (this.options.type) {\n      case 'local':     relative = ctx._startOffset; break;\n      case 'immediate': relative = stream.pos - this.offsetType.size(); break;\n      case 'parent':    relative = ctx.parent._startOffset; break;\n      default:\n        var c = ctx;\n        while (c.parent) {\n          c = c.parent;\n        }\n\n        relative = c._startOffset || 0;\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(ctx);\n    }\n\n    const ptr = offset + relative;\n\n    if (this.type != null) {\n      let val = null;\n      const decodeValue = () => {\n        if (val != null) { return val; }\n\n        const { pos } = stream;\n        stream.pos = ptr;\n        val = this.type.decode(stream, ctx);\n        stream.pos = pos;\n        return val;\n      };\n\n      // If this is a lazy pointer, define a getter to decode only when needed.\n      // This obviously only works when the pointer is contained by a Struct.\n      if (this.options.lazy) {\n        return new utils.PropertyDescriptor({\n          get: decodeValue});\n      }\n\n      return decodeValue();\n    } else {\n      return ptr;\n    }\n  }\n\n  size(val, ctx) {\n    const parent = ctx;\n    switch (this.options.type) {\n      case 'local': case 'immediate':\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        break;\n      default: // global\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    if (val && ctx) {\n      // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n      let size = type.size(val, parent);\n      ctx.pointerSize += size;\n    }\n\n    return this.offsetType.size();\n  }\n\n  encode(stream, val, ctx) {\n    let relative;\n    const parent = ctx;\n    if ((val == null)) {\n      this.offsetType.encode(stream, this.options.nullValue);\n      return;\n    }\n\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx.startOffset;\n        break;\n      case 'immediate':\n        relative = stream.pos + this.offsetType.size(val, parent);\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        relative = ctx.startOffset;\n        break;\n      default: // global\n        relative = 0;\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(parent.val);\n    }\n\n    this.offsetType.encode(stream, ctx.pointerOffset - relative);\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    ctx.pointers.push({\n      type,\n      val,\n      parent\n    });\n\n    return ctx.pointerOffset += type.size(val, parent);\n  }\n}\n\n// A pointer whose type is determined at decode time\nexport class VoidPointer {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,YAAvB;AACA,SAAQC,IAAR,QAAmB,WAAnB;AAEA,OAAO,MAAMC,OAAN,SAAsBD,IAAtB,CAA2B;EAChCE,WAAW,CAACC,UAAD,EAAaC,IAAb,EAAiC;IAAA,IAAdC,OAAc,uEAAJ,EAAI;IAC1C;IACA,KAAKF,UAAL,GAAkBA,UAAlB;IACA,KAAKC,IAAL,GAAYA,IAAZ;IACA,KAAKC,OAAL,GAAeA,OAAf;;IACA,IAAI,KAAKD,IAAL,KAAc,MAAlB,EAA0B;MAAE,KAAKA,IAAL,GAAY,IAAZ;IAAmB;;IAC/C,IAAI,KAAKC,OAAL,CAAaD,IAAb,IAAqB,IAAzB,EAA+B;MAAE,KAAKC,OAAL,CAAaD,IAAb,GAAoB,OAApB;IAA8B;;IAC/D,IAAI,KAAKC,OAAL,CAAaC,SAAb,IAA0B,IAA9B,EAAoC;MAAE,KAAKD,OAAL,CAAaC,SAAb,GAAyB,IAAzB;IAAgC;;IACtE,IAAI,KAAKD,OAAL,CAAaE,SAAb,IAA0B,IAA9B,EAAoC;MAAE,KAAKF,OAAL,CAAaE,SAAb,GAAyB,CAAzB;IAA6B;;IACnE,IAAI,KAAKF,OAAL,CAAaG,IAAb,IAAqB,IAAzB,EAA+B;MAAE,KAAKH,OAAL,CAAaG,IAAb,GAAoB,KAApB;IAA4B;;IAC7D,IAAI,KAAKH,OAAL,CAAaI,UAAjB,EAA6B;MAC3B,IAAI,OAAO,KAAKJ,OAAL,CAAaI,UAApB,KAAmC,UAAvC,EAAmD;QACjD,MAAM,IAAIC,KAAJ,CAAU,sCAAV,CAAN;MACD;;MACD,KAAKC,gBAAL,GAAwBN,OAAO,CAACI,UAAhC;IACD;EACF;;EAEDG,MAAM,CAACC,MAAD,EAASC,GAAT,EAAc;IAClB,MAAMC,MAAM,GAAG,KAAKZ,UAAL,CAAgBS,MAAhB,CAAuBC,MAAvB,EAA+BC,GAA/B,CAAf,CADkB,CAGlB;;IACA,IAAKC,MAAM,KAAK,KAAKV,OAAL,CAAaE,SAAzB,IAAuC,KAAKF,OAAL,CAAaC,SAAxD,EAAmE;MACjE,OAAO,IAAP;IACD;;IAED,IAAIU,QAAJ;;IACA,QAAQ,KAAKX,OAAL,CAAaD,IAArB;MACE,KAAK,OAAL;QAAkBY,QAAQ,GAAGF,GAAG,CAACG,YAAf;QAA6B;;MAC/C,KAAK,WAAL;QAAkBD,QAAQ,GAAGH,MAAM,CAACK,GAAP,GAAa,KAAKf,UAAL,CAAgBgB,IAAhB,EAAxB;QAAgD;;MAClE,KAAK,QAAL;QAAkBH,QAAQ,GAAGF,GAAG,CAACM,MAAJ,CAAWH,YAAtB;QAAoC;;MACtD;QACE,IAAII,CAAC,GAAGP,GAAR;;QACA,OAAOO,CAAC,CAACD,MAAT,EAAiB;UACfC,CAAC,GAAGA,CAAC,CAACD,MAAN;QACD;;QAEDJ,QAAQ,GAAGK,CAAC,CAACJ,YAAF,IAAkB,CAA7B;IAVJ;;IAaA,IAAI,KAAKZ,OAAL,CAAaI,UAAjB,EAA6B;MAC3BO,QAAQ,IAAI,KAAKL,gBAAL,CAAsBG,GAAtB,CAAZ;IACD;;IAED,MAAMQ,GAAG,GAAGP,MAAM,GAAGC,QAArB;;IAEA,IAAI,KAAKZ,IAAL,IAAa,IAAjB,EAAuB;MACrB,IAAImB,GAAG,GAAG,IAAV;;MACA,MAAMC,WAAW,GAAG,MAAM;QACxB,IAAID,GAAG,IAAI,IAAX,EAAiB;UAAE,OAAOA,GAAP;QAAa;;QAEhC,MAAM;UAAEL;QAAF,IAAUL,MAAhB;QACAA,MAAM,CAACK,GAAP,GAAaI,GAAb;QACAC,GAAG,GAAG,KAAKnB,IAAL,CAAUQ,MAAV,CAAiBC,MAAjB,EAAyBC,GAAzB,CAAN;QACAD,MAAM,CAACK,GAAP,GAAaA,GAAb;QACA,OAAOK,GAAP;MACD,CARD,CAFqB,CAYrB;MACA;;;MACA,IAAI,KAAKlB,OAAL,CAAaG,IAAjB,EAAuB;QACrB,OAAO,IAAIT,KAAK,CAAC0B,kBAAV,CAA6B;UAClCC,GAAG,EAAEF;QAD6B,CAA7B,CAAP;MAED;;MAED,OAAOA,WAAW,EAAlB;IACD,CApBD,MAoBO;MACL,OAAOF,GAAP;IACD;EACF;;EAEDH,IAAI,CAACI,GAAD,EAAMT,GAAN,EAAW;IACb,MAAMM,MAAM,GAAGN,GAAf;;IACA,QAAQ,KAAKT,OAAL,CAAaD,IAArB;MACE,KAAK,OAAL;MAAc,KAAK,WAAL;QACZ;;MACF,KAAK,QAAL;QACEU,GAAG,GAAGA,GAAG,CAACM,MAAV;QACA;;MACF;QAAS;QACP,OAAON,GAAG,CAACM,MAAX,EAAmB;UACjBN,GAAG,GAAGA,GAAG,CAACM,MAAV;QACD;;IATL;;IAYA,IAAI;MAAEhB;IAAF,IAAW,IAAf;;IACA,IAAIA,IAAI,IAAI,IAAZ,EAAkB;MAChB,IAAI,EAAEmB,GAAG,YAAYI,WAAjB,CAAJ,EAAmC;QACjC,MAAM,IAAIjB,KAAJ,CAAU,uBAAV,CAAN;MACD;;MAED,CAAC;QAAEN;MAAF,IAAWmB,GAAZ;MACAA,GAAG,GAAGA,GAAG,CAACK,KAAV;IACD;;IAED,IAAIL,GAAG,IAAIT,GAAX,EAAgB;MACd;MACA,IAAIK,IAAI,GAAGf,IAAI,CAACe,IAAL,CAAUI,GAAV,EAAeH,MAAf,CAAX;MACAN,GAAG,CAACe,WAAJ,IAAmBV,IAAnB;IACD;;IAED,OAAO,KAAKhB,UAAL,CAAgBgB,IAAhB,EAAP;EACD;;EAEDW,MAAM,CAACjB,MAAD,EAASU,GAAT,EAAcT,GAAd,EAAmB;IACvB,IAAIE,QAAJ;IACA,MAAMI,MAAM,GAAGN,GAAf;;IACA,IAAKS,GAAG,IAAI,IAAZ,EAAmB;MACjB,KAAKpB,UAAL,CAAgB2B,MAAhB,CAAuBjB,MAAvB,EAA+B,KAAKR,OAAL,CAAaE,SAA5C;MACA;IACD;;IAED,QAAQ,KAAKF,OAAL,CAAaD,IAArB;MACE,KAAK,OAAL;QACEY,QAAQ,GAAGF,GAAG,CAACiB,WAAf;QACA;;MACF,KAAK,WAAL;QACEf,QAAQ,GAAGH,MAAM,CAACK,GAAP,GAAa,KAAKf,UAAL,CAAgBgB,IAAhB,CAAqBI,GAArB,EAA0BH,MAA1B,CAAxB;QACA;;MACF,KAAK,QAAL;QACEN,GAAG,GAAGA,GAAG,CAACM,MAAV;QACAJ,QAAQ,GAAGF,GAAG,CAACiB,WAAf;QACA;;MACF;QAAS;QACPf,QAAQ,GAAG,CAAX;;QACA,OAAOF,GAAG,CAACM,MAAX,EAAmB;UACjBN,GAAG,GAAGA,GAAG,CAACM,MAAV;QACD;;IAfL;;IAkBA,IAAI,KAAKf,OAAL,CAAaI,UAAjB,EAA6B;MAC3BO,QAAQ,IAAI,KAAKL,gBAAL,CAAsBS,MAAM,CAACG,GAA7B,CAAZ;IACD;;IAED,KAAKpB,UAAL,CAAgB2B,MAAhB,CAAuBjB,MAAvB,EAA+BC,GAAG,CAACkB,aAAJ,GAAoBhB,QAAnD;IAEA,IAAI;MAAEZ;IAAF,IAAW,IAAf;;IACA,IAAIA,IAAI,IAAI,IAAZ,EAAkB;MAChB,IAAI,EAAEmB,GAAG,YAAYI,WAAjB,CAAJ,EAAmC;QACjC,MAAM,IAAIjB,KAAJ,CAAU,uBAAV,CAAN;MACD;;MAED,CAAC;QAAEN;MAAF,IAAWmB,GAAZ;MACAA,GAAG,GAAGA,GAAG,CAACK,KAAV;IACD;;IAEDd,GAAG,CAACmB,QAAJ,CAAaC,IAAb,CAAkB;MAChB9B,IADgB;MAEhBmB,GAFgB;MAGhBH;IAHgB,CAAlB;IAMA,OAAON,GAAG,CAACkB,aAAJ,IAAqB5B,IAAI,CAACe,IAAL,CAAUI,GAAV,EAAeH,MAAf,CAA5B;EACD;;AA1J+B,C,CA6JlC;;AACA,OAAO,MAAMO,WAAN,CAAkB;EACvBzB,WAAW,CAACE,IAAD,EAAOwB,KAAP,EAAc;IACvB,KAAKxB,IAAL,GAAYA,IAAZ;IACA,KAAKwB,KAAL,GAAaA,KAAb;EACD;;AAJsB"},"metadata":{},"sourceType":"module"}