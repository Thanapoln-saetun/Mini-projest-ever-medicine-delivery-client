{"ast":null,"code":"import _classCallCheck from \"E:/Mern login/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mern login/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"E:/Mern login/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mern login/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Struct } from './Struct.js';\n\nvar getPath = function getPath(object, pathArray) {\n  return pathArray.reduce(function (prevObj, key) {\n    return prevObj && prevObj[key];\n  }, object);\n};\n\nexport var VersionedStruct = /*#__PURE__*/function (_Struct) {\n  _inherits(VersionedStruct, _Struct);\n\n  var _super = _createSuper(VersionedStruct);\n\n  function VersionedStruct(type) {\n    var _this;\n\n    var versions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, VersionedStruct);\n\n    _this = _super.call(this);\n    _this.type = type;\n    _this.versions = versions;\n\n    if (typeof type === 'string') {\n      _this.versionPath = type.split('.');\n    }\n\n    return _this;\n  }\n\n  _createClass(VersionedStruct, [{\n    key: \"decode\",\n    value: function decode(stream, parent) {\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var res = this._setup(stream, parent, length);\n\n      if (typeof this.type === 'string') {\n        res.version = getPath(parent, this.versionPath);\n      } else {\n        res.version = this.type.decode(stream);\n      }\n\n      if (this.versions.header) {\n        this._parseFields(stream, res, this.versions.header);\n      }\n\n      var fields = this.versions[res.version];\n\n      if (fields == null) {\n        throw new Error(\"Unknown version \".concat(res.version));\n      }\n\n      if (fields instanceof VersionedStruct) {\n        return fields.decode(stream, parent);\n      }\n\n      this._parseFields(stream, res, fields);\n\n      if (this.process != null) {\n        this.process.call(res, stream);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"size\",\n    value: function size(val, parent) {\n      var includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var key, type;\n\n      if (!val) {\n        throw new Error('Not a fixed size');\n      }\n\n      if (this.preEncode != null) {\n        this.preEncode.call(val);\n      }\n\n      var ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      var size = 0;\n\n      if (typeof this.type !== 'string') {\n        size += this.type.size(val.version, ctx);\n      }\n\n      if (this.versions.header) {\n        for (key in this.versions.header) {\n          type = this.versions.header[key];\n\n          if (type.size != null) {\n            size += type.size(val[key], ctx);\n          }\n        }\n      }\n\n      var fields = this.versions[val.version];\n\n      if (fields == null) {\n        throw new Error(\"Unknown version \".concat(val.version));\n      }\n\n      for (key in fields) {\n        type = fields[key];\n\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n\n      return size;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(stream, val, parent) {\n      var key, type;\n\n      if (this.preEncode != null) {\n        this.preEncode.call(val, stream);\n      }\n\n      var ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n      if (typeof this.type !== 'string') {\n        this.type.encode(stream, val.version);\n      }\n\n      if (this.versions.header) {\n        for (key in this.versions.header) {\n          type = this.versions.header[key];\n\n          if (type.encode != null) {\n            type.encode(stream, val[key], ctx);\n          }\n        }\n      }\n\n      var fields = this.versions[val.version];\n\n      for (key in fields) {\n        type = fields[key];\n\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n\n      var i = 0;\n\n      while (i < ctx.pointers.length) {\n        var ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    }\n  }]);\n\n  return VersionedStruct;\n}(Struct);","map":{"version":3,"names":["Struct","getPath","object","pathArray","reduce","prevObj","key","VersionedStruct","type","versions","versionPath","split","stream","parent","length","res","_setup","version","decode","header","_parseFields","fields","Error","process","call","val","includePointers","preEncode","ctx","pointerSize","size","pointers","startOffset","pos","pointerOffset","encode","i","ptr"],"sources":["E:/Mern login/client/node_modules/restructure/src/VersionedStruct.js"],"sourcesContent":["import {Struct} from './Struct.js';\n\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\n\nexport class VersionedStruct extends Struct {\n  constructor(type, versions = {}) {\n    super();\n    this.type = type;\n    this.versions = versions;\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n\n  decode(stream, parent, length = 0) {\n    const res = this._setup(stream, parent, length);\n\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n\n    const fields = this.versions[res.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n\n    this._parseFields(stream, res, fields);\n\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n\n  size(val, parent, includePointers = true) {\n    let key, type;\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    let size = 0;\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n\n    for (key in fields) {\n      type = fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n\n    return size;\n  }\n\n  encode(stream, val, parent) {\n    let key, type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    for (key in fields) {\n      type = fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}