{"ast":null,"code":"import _classCallCheck from \"E:/Mern login/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Mern login/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"E:/Mern login/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/Mern login/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as utils from './utils.js';\nimport { Base } from './Base.js';\nexport var Pointer = /*#__PURE__*/function (_Base) {\n  _inherits(Pointer, _Base);\n\n  var _super = _createSuper(Pointer);\n\n  function Pointer(offsetType, type) {\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Pointer);\n\n    _this = _super.call(this);\n    _this.offsetType = offsetType;\n    _this.type = type;\n    _this.options = options;\n\n    if (_this.type === 'void') {\n      _this.type = null;\n    }\n\n    if (_this.options.type == null) {\n      _this.options.type = 'local';\n    }\n\n    if (_this.options.allowNull == null) {\n      _this.options.allowNull = true;\n    }\n\n    if (_this.options.nullValue == null) {\n      _this.options.nullValue = 0;\n    }\n\n    if (_this.options.lazy == null) {\n      _this.options.lazy = false;\n    }\n\n    if (_this.options.relativeTo) {\n      if (typeof _this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n\n      _this.relativeToGetter = options.relativeTo;\n    }\n\n    return _this;\n  }\n\n  _createClass(Pointer, [{\n    key: \"decode\",\n    value: function decode(stream, ctx) {\n      var _this2 = this;\n\n      var offset = this.offsetType.decode(stream, ctx); // handle NULL pointers\n\n      if (offset === this.options.nullValue && this.options.allowNull) {\n        return null;\n      }\n\n      var relative;\n\n      switch (this.options.type) {\n        case 'local':\n          relative = ctx._startOffset;\n          break;\n\n        case 'immediate':\n          relative = stream.pos - this.offsetType.size();\n          break;\n\n        case 'parent':\n          relative = ctx.parent._startOffset;\n          break;\n\n        default:\n          var c = ctx;\n\n          while (c.parent) {\n            c = c.parent;\n          }\n\n          relative = c._startOffset || 0;\n      }\n\n      if (this.options.relativeTo) {\n        relative += this.relativeToGetter(ctx);\n      }\n\n      var ptr = offset + relative;\n\n      if (this.type != null) {\n        var val = null;\n\n        var decodeValue = function decodeValue() {\n          if (val != null) {\n            return val;\n          }\n\n          var pos = stream.pos;\n          stream.pos = ptr;\n          val = _this2.type.decode(stream, ctx);\n          stream.pos = pos;\n          return val;\n        }; // If this is a lazy pointer, define a getter to decode only when needed.\n        // This obviously only works when the pointer is contained by a Struct.\n\n\n        if (this.options.lazy) {\n          return new utils.PropertyDescriptor({\n            get: decodeValue\n          });\n        }\n\n        return decodeValue();\n      } else {\n        return ptr;\n      }\n    }\n  }, {\n    key: \"size\",\n    value: function size(val, ctx) {\n      var parent = ctx;\n\n      switch (this.options.type) {\n        case 'local':\n        case 'immediate':\n          break;\n\n        case 'parent':\n          ctx = ctx.parent;\n          break;\n\n        default:\n          // global\n          while (ctx.parent) {\n            ctx = ctx.parent;\n          }\n\n      }\n\n      var type = this.type;\n\n      if (type == null) {\n        if (!(val instanceof VoidPointer)) {\n          throw new Error(\"Must be a VoidPointer\");\n        }\n\n        var _val = val;\n        type = _val.type;\n        val = val.value;\n      }\n\n      if (val && ctx) {\n        // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n        var size = type.size(val, parent);\n        ctx.pointerSize += size;\n      }\n\n      return this.offsetType.size();\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(stream, val, ctx) {\n      var relative;\n      var parent = ctx;\n\n      if (val == null) {\n        this.offsetType.encode(stream, this.options.nullValue);\n        return;\n      }\n\n      switch (this.options.type) {\n        case 'local':\n          relative = ctx.startOffset;\n          break;\n\n        case 'immediate':\n          relative = stream.pos + this.offsetType.size(val, parent);\n          break;\n\n        case 'parent':\n          ctx = ctx.parent;\n          relative = ctx.startOffset;\n          break;\n\n        default:\n          // global\n          relative = 0;\n\n          while (ctx.parent) {\n            ctx = ctx.parent;\n          }\n\n      }\n\n      if (this.options.relativeTo) {\n        relative += this.relativeToGetter(parent.val);\n      }\n\n      this.offsetType.encode(stream, ctx.pointerOffset - relative);\n      var type = this.type;\n\n      if (type == null) {\n        if (!(val instanceof VoidPointer)) {\n          throw new Error(\"Must be a VoidPointer\");\n        }\n\n        var _val2 = val;\n        type = _val2.type;\n        val = val.value;\n      }\n\n      ctx.pointers.push({\n        type: type,\n        val: val,\n        parent: parent\n      });\n      return ctx.pointerOffset += type.size(val, parent);\n    }\n  }]);\n\n  return Pointer;\n}(Base); // A pointer whose type is determined at decode time\n\nexport var VoidPointer = /*#__PURE__*/_createClass(function VoidPointer(type, value) {\n  _classCallCheck(this, VoidPointer);\n\n  this.type = type;\n  this.value = value;\n});","map":{"version":3,"names":["utils","Base","Pointer","offsetType","type","options","allowNull","nullValue","lazy","relativeTo","Error","relativeToGetter","stream","ctx","offset","decode","relative","_startOffset","pos","size","parent","c","ptr","val","decodeValue","PropertyDescriptor","get","VoidPointer","value","pointerSize","encode","startOffset","pointerOffset","pointers","push"],"sources":["E:/Mern login/client/node_modules/restructure/src/Pointer.js"],"sourcesContent":["import * as utils from './utils.js';\nimport {Base} from './Base.js';\n\nexport class Pointer extends Base {\n  constructor(offsetType, type, options = {}) {\n    super();\n    this.offsetType = offsetType;\n    this.type = type;\n    this.options = options;\n    if (this.type === 'void') { this.type = null; }\n    if (this.options.type == null) { this.options.type = 'local'; }\n    if (this.options.allowNull == null) { this.options.allowNull = true; }\n    if (this.options.nullValue == null) { this.options.nullValue = 0; }\n    if (this.options.lazy == null) { this.options.lazy = false; }\n    if (this.options.relativeTo) {\n      if (typeof this.options.relativeTo !== 'function') {\n        throw new Error('relativeTo option must be a function');\n      }\n      this.relativeToGetter = options.relativeTo;\n    }\n  }\n\n  decode(stream, ctx) {\n    const offset = this.offsetType.decode(stream, ctx);\n\n    // handle NULL pointers\n    if ((offset === this.options.nullValue) && this.options.allowNull) {\n      return null;\n    }\n\n    let relative;\n    switch (this.options.type) {\n      case 'local':     relative = ctx._startOffset; break;\n      case 'immediate': relative = stream.pos - this.offsetType.size(); break;\n      case 'parent':    relative = ctx.parent._startOffset; break;\n      default:\n        var c = ctx;\n        while (c.parent) {\n          c = c.parent;\n        }\n\n        relative = c._startOffset || 0;\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(ctx);\n    }\n\n    const ptr = offset + relative;\n\n    if (this.type != null) {\n      let val = null;\n      const decodeValue = () => {\n        if (val != null) { return val; }\n\n        const { pos } = stream;\n        stream.pos = ptr;\n        val = this.type.decode(stream, ctx);\n        stream.pos = pos;\n        return val;\n      };\n\n      // If this is a lazy pointer, define a getter to decode only when needed.\n      // This obviously only works when the pointer is contained by a Struct.\n      if (this.options.lazy) {\n        return new utils.PropertyDescriptor({\n          get: decodeValue});\n      }\n\n      return decodeValue();\n    } else {\n      return ptr;\n    }\n  }\n\n  size(val, ctx) {\n    const parent = ctx;\n    switch (this.options.type) {\n      case 'local': case 'immediate':\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        break;\n      default: // global\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    if (val && ctx) {\n      // Must be written as two separate lines rather than += in case `type.size` mutates ctx.pointerSize.\n      let size = type.size(val, parent);\n      ctx.pointerSize += size;\n    }\n\n    return this.offsetType.size();\n  }\n\n  encode(stream, val, ctx) {\n    let relative;\n    const parent = ctx;\n    if ((val == null)) {\n      this.offsetType.encode(stream, this.options.nullValue);\n      return;\n    }\n\n    switch (this.options.type) {\n      case 'local':\n        relative = ctx.startOffset;\n        break;\n      case 'immediate':\n        relative = stream.pos + this.offsetType.size(val, parent);\n        break;\n      case 'parent':\n        ctx = ctx.parent;\n        relative = ctx.startOffset;\n        break;\n      default: // global\n        relative = 0;\n        while (ctx.parent) {\n          ctx = ctx.parent;\n        }\n    }\n\n    if (this.options.relativeTo) {\n      relative += this.relativeToGetter(parent.val);\n    }\n\n    this.offsetType.encode(stream, ctx.pointerOffset - relative);\n\n    let { type } = this;\n    if (type == null) {\n      if (!(val instanceof VoidPointer)) {\n        throw new Error(\"Must be a VoidPointer\");\n      }\n\n      ({ type } = val);\n      val = val.value;\n    }\n\n    ctx.pointers.push({\n      type,\n      val,\n      parent\n    });\n\n    return ctx.pointerOffset += type.size(val, parent);\n  }\n}\n\n// A pointer whose type is determined at decode time\nexport class VoidPointer {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}