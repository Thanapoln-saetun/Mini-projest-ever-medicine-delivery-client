{"ast":null,"code":"import { Struct } from './Struct.js';\n\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\n\nexport class VersionedStruct extends Struct {\n  constructor(type) {\n    let versions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.type = type;\n    this.versions = versions;\n\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n\n  decode(stream, parent) {\n    let length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    const res = this._setup(stream, parent, length);\n\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n\n    const fields = this.versions[res.version];\n\n    if (fields == null) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n\n    this._parseFields(stream, res, fields);\n\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n\n    return res;\n  }\n\n  size(val, parent) {\n    let includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let key, type;\n\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n    let size = 0;\n\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n\n    if (fields == null) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n\n    for (key in fields) {\n      type = fields[key];\n\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n\n    return size;\n  }\n\n  encode(stream, val, parent) {\n    let key, type;\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n\n    for (key in fields) {\n      type = fields[key];\n\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n\n    let i = 0;\n\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n\n}","map":{"version":3,"names":["Struct","getPath","object","pathArray","reduce","prevObj","key","VersionedStruct","constructor","type","versions","versionPath","split","decode","stream","parent","length","res","_setup","version","header","_parseFields","fields","Error","process","call","size","val","includePointers","preEncode","ctx","pointerSize","encode","pointers","startOffset","pos","pointerOffset","i","ptr"],"sources":["E:/Mern login/client/node_modules/restructure/src/VersionedStruct.js"],"sourcesContent":["import {Struct} from './Struct.js';\n\nconst getPath = (object, pathArray) => {\n  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);\n};\n\nexport class VersionedStruct extends Struct {\n  constructor(type, versions = {}) {\n    super();\n    this.type = type;\n    this.versions = versions;\n    if (typeof type === 'string') {\n      this.versionPath = type.split('.');\n    }\n  }\n\n  decode(stream, parent, length = 0) {\n    const res = this._setup(stream, parent, length);\n\n    if (typeof this.type === 'string') {\n      res.version = getPath(parent, this.versionPath);\n    } else {\n      res.version = this.type.decode(stream);\n    }\n\n    if (this.versions.header) {\n      this._parseFields(stream, res, this.versions.header);\n    }\n\n    const fields = this.versions[res.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${res.version}`);\n    }\n\n    if (fields instanceof VersionedStruct) {\n      return fields.decode(stream, parent);\n    }\n\n    this._parseFields(stream, res, fields);\n\n    if (this.process != null) {\n      this.process.call(res, stream);\n    }\n    return res;\n  }\n\n  size(val, parent, includePointers = true) {\n    let key, type;\n    if (!val) {\n      throw new Error('Not a fixed size');\n    }\n\n    if (this.preEncode != null) {\n      this.preEncode.call(val);\n    }\n\n    const ctx = {\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    let size = 0;\n    if (typeof this.type !== 'string') {\n      size += this.type.size(val.version, ctx);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    if ((fields == null)) {\n      throw new Error(`Unknown version ${val.version}`);\n    }\n\n    for (key in fields) {\n      type = fields[key];\n      if (type.size != null) {\n        size += type.size(val[key], ctx);\n      }\n    }\n\n    if (includePointers) {\n      size += ctx.pointerSize;\n    }\n\n    return size;\n  }\n\n  encode(stream, val, parent) {\n    let key, type;\n    if (this.preEncode != null) {\n      this.preEncode.call(val, stream);\n    }\n\n    const ctx = {\n      pointers: [],\n      startOffset: stream.pos,\n      parent,\n      val,\n      pointerSize: 0\n    };\n\n    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n\n    if (typeof this.type !== 'string') {\n      this.type.encode(stream, val.version);\n    }\n\n    if (this.versions.header) {\n      for (key in this.versions.header) {\n        type = this.versions.header[key];\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n    }\n\n    const fields = this.versions[val.version];\n    for (key in fields) {\n      type = fields[key];\n      if (type.encode != null) {\n        type.encode(stream, val[key], ctx);\n      }\n    }\n\n    let i = 0;\n    while (i < ctx.pointers.length) {\n      const ptr = ctx.pointers[i++];\n      ptr.type.encode(stream, ptr.val, ptr.parent);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}