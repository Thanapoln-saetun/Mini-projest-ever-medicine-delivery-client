{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"E:/Mern login/client/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"E:/Mern login/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _defineProperty = require(\"E:/Mern login/client/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _regeneratorRuntime = require(\"E:/Mern login/client/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _classCallCheck = require(\"E:/Mern login/client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"E:/Mern login/client/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar INITIAL_STATE = 1;\nvar FAIL_STATE = 0;\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\n\nvar StateMachine = /*#__PURE__*/function () {\n  function StateMachine(dfa) {\n    _classCallCheck(this, StateMachine);\n\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n\n\n  _createClass(StateMachine, [{\n    key: \"match\",\n    value: function match(str) {\n      var self = this;\n      return _defineProperty({}, Symbol.iterator, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var state, startRun, lastAccepting, lastState, p, c;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                state = INITIAL_STATE;\n                startRun = null;\n                lastAccepting = null;\n                lastState = null;\n                p = 0;\n\n              case 5:\n                if (!(p < str.length)) {\n                  _context.next = 21;\n                  break;\n                }\n\n                c = str[p];\n                lastState = state;\n                state = self.stateTable[state][c];\n\n                if (!(state === FAIL_STATE)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.next = 13;\n                return [startRun, lastAccepting, self.tags[lastState]];\n\n              case 13:\n                // reset the state as if we started over from the initial state\n                state = self.stateTable[INITIAL_STATE][c];\n                startRun = null;\n\n              case 15:\n                // start a run if not in the failure state\n                if (state !== FAIL_STATE && startRun == null) {\n                  startRun = p;\n                } // if accepting, mark the potential match end\n\n\n                if (self.accepting[state]) {\n                  lastAccepting = p;\n                } // reset the state to the initial state if we get into the failure state\n\n\n                if (state === FAIL_STATE) {\n                  state = INITIAL_STATE;\n                }\n\n              case 18:\n                p++;\n                _context.next = 5;\n                break;\n\n              case 21:\n                if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                _context.next = 24;\n                return [startRun, lastAccepting, self.tags[state]];\n\n              case 24:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n    /**\n     * For each match over the input sequence, action functions matching\n     * the tag definitions in the input pattern are called with the startIndex,\n     * endIndex, and sub-match sequence.\n     */\n\n  }, {\n    key: \"apply\",\n    value: function apply(str, actions) {\n      var _iterator = _createForOfIteratorHelper(this.match(str)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 3),\n              start = _step$value[0],\n              end = _step$value[1],\n              tags = _step$value[2];\n\n          var _iterator2 = _createForOfIteratorHelper(tags),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var tag = _step2.value;\n\n              if (typeof actions[tag] === 'function') {\n                actions[tag](start, end, str.slice(start, end + 1));\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n\n  return StateMachine;\n}();\n\nmodule.exports = StateMachine;","map":{"version":3,"mappings":";;;;;;;;;;;;;;AAAA,IAAMA,aAAa,GAAG,CAAtB;AACA,IAAMC,UAAU,GAAG,CAAnB;;;;;;IAMqBC,Y;EACnBC,sBAAYC,GAAZD,EAAiB;IAAA;;SACVE,aAAaD,GAAG,CAACC;SACjBC,YAAYF,GAAG,CAACE;SAChBC,OAAOH,GAAG,CAACG;;;;;;;;;;WAOlBC,eAAMC,GAAND,EAAW;UACLE,IAAI,GAAG;iCAEPC,MAAM,CAACC;;;;;;gBACHC,QAAQb;gBACRc,WAAW;gBACXC,gBAAgB;gBAChBC,YAAY;gBAEPC,IAAI;;;sBAAGA,CAAC,GAAGR,GAAG,CAACS;;;;;gBAClBC,IAAIV,GAAG,CAACQ,CAAD;gBAEXD,SAAS,GAAGH,KAAZG;gBACAH,KAAK,GAAGH,IAAI,CAACL,UAALK,CAAgBG,KAAhBH,EAAuBS,CAAvBT,CAARG;;sBAEIA,KAAK,KAAKZ;;;;;sBAERa,QAAQ,IAAI,IAAZA,IAAoBC,aAAa,IAAI,IAArCD,IAA6CC,aAAa,IAAID;;;;;;uBAC1D,CAACA,QAAD,EAAWC,aAAX,EAA0BL,IAAI,CAACH,IAALG,CAAUM,SAAVN,CAA1B;;;gBAHgB;gBAOxBG,KAAK,GAAGH,IAAI,CAACL,UAALK,CAAgBV,aAAhBU,EAA+BS,CAA/BT,CAARG;gBACAC,QAAQ,GAAG,IAAXA;;;gBAdiC;oBAkB/BD,KAAK,KAAKZ,UAAVY,IAAwBC,QAAQ,IAAI,MAAM;kBAC5CA,QAAQ,GAAGG,CAAXH;gBAnBiC;;;oBAuB/BJ,IAAI,CAACJ,SAALI,CAAeG,KAAfH,GAAuB;kBACzBK,aAAa,GAAGE,CAAhBF;gBAxBiC;;;oBA4B/BF,KAAK,KAAKZ,YAAY;kBACxBY,KAAK,GAAGb,aAARa;;;;gBA7B4BI,CAAC;;;;;sBAkC7BH,QAAQ,IAAI,IAAZA,IAAoBC,aAAa,IAAI,IAArCD,IAA6CC,aAAa,IAAID;;;;;;uBAC1D,CAACA,QAAD,EAAWC,aAAX,EAA0BL,IAAI,CAACH,IAALG,CAAUG,KAAVH,CAA1B;;;;;;;;;;;;;;;;;;WAWdU,eAAMX,GAANW,EAAWC,OAAXD,EAAoB;MAAA,2CACa,KAAKZ,KAAL,CAAWC,GAAX,CADb;MAAA;;MAAA;4DAC8B;UAAA;UAAA,IAAtCa,KAAsC;UAAA,IAA/BC,GAA+B;UAAA,IAA1BhB,IAA0B;;UAAA,4CAC9BA,IAD8B;UAAA;;UAAA;mEACxB;cAAA,IAAbiB,GAAa;;kBAChB,OAAOH,OAAO,CAACG,GAAD,CAAd,KAAwB,YAAY;gBACtCH,OAAO,CAACG,GAAD,CAAPH,CAAaC,KAAbD,EAAoBE,GAApBF,EAAyBZ,GAAG,CAACgB,KAAJhB,CAAUa,KAAVb,EAAiBc,GAAG,GAAG,CAAvBd,CAAzBY;;;UAH0C;YAAA;UAAA;YAAA;UAAA;;MAD9B;QAAA;MAAA;QAAA;MAAA","names":["INITIAL_STATE","FAIL_STATE","StateMachine","constructor","dfa","stateTable","accepting","tags","match","str","self","Symbol","iterator","state","startRun","lastAccepting","lastState","p","length","c","apply","actions","start","end","tag","slice"],"sources":["E:\\Mern login\\client\\node_modules\\dfa\\src\\StateMachine.js"],"sourcesContent":["const INITIAL_STATE = 1;\nconst FAIL_STATE = 0;\n\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\nexport default class StateMachine {\n  constructor(dfa) {\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n  match(str) {\n    let self = this;\n    return {\n      *[Symbol.iterator]() {\n        let state = INITIAL_STATE;\n        let startRun = null;\n        let lastAccepting = null;\n        let lastState = null;\n\n        for (let p = 0; p < str.length; p++) {\n          let c = str[p];\n\n          lastState = state;\n          state = self.stateTable[state][c];\n\n          if (state === FAIL_STATE) {\n            // yield the last match if any\n            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n              yield [startRun, lastAccepting, self.tags[lastState]];\n            }\n\n            // reset the state as if we started over from the initial state\n            state = self.stateTable[INITIAL_STATE][c];\n            startRun = null;\n          }\n\n          // start a run if not in the failure state\n          if (state !== FAIL_STATE && startRun == null) {\n            startRun = p;\n          }\n\n          // if accepting, mark the potential match end\n          if (self.accepting[state]) {\n            lastAccepting = p;\n          }\n\n          // reset the state to the initial state if we get into the failure state\n          if (state === FAIL_STATE) {\n            state = INITIAL_STATE;\n          }\n        }\n\n        // yield the last match if any\n        if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n          yield [startRun, lastAccepting, self.tags[state]];\n        }\n      }\n    };\n  }\n\n  /**\n   * For each match over the input sequence, action functions matching\n   * the tag definitions in the input pattern are called with the startIndex,\n   * endIndex, and sub-match sequence.\n   */\n  apply(str, actions) {\n    for (let [start, end, tags] of this.match(str)) {\n      for (let tag of tags) {\n        if (typeof actions[tag] === 'function') {\n          actions[tag](start, end, str.slice(start, end + 1));\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}